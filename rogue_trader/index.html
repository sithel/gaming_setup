<!DOCTYPE html>
<html>
  <head>
    <meta charset=utf-8>
    <title>My first Three.js app</title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
    </style>
  </head>
  <body>
    <script src="three.min.js"></script>
    <script src="orbitControls.js"></script>
    <script>

var orbits = [];
var colors = [0xff0000, 0xffbf00, 0x80ff00, 0x00ffbf, 0xff00ff, 0xff00ff];
var UNITS_PER_30_MIN = 10;
var UNIT_PER_FRAME = 0.01;

function generateOrbit(num, freq, offset, distance, appraoch, scene) {
  var material = new THREE.MeshBasicMaterial({wireframe: true, color: colors[num-1], specular: 0x555555, shininess: 30, opacity: 0.3, transparent: true});
  var radius = distance;  // did Sarah give radius or diameter? 
  
  var circleGeometry = new THREE.CircleGeometry( radius, 60);
  var orbit = new THREE.Mesh( circleGeometry, material );
  // var cylinderGeometry = new THREE.CylinderGeometry( radius, radius, 0.2, 32 );
  // var orbit = new THREE.Mesh( cylinderGeometry, material );
  scene.add(orbit);

  var circumference = 2 * Math.PI * radius;
  // arc length = center angle in radians * radius
  var shipRotationRadians = UNITS_PER_30_MIN / radius;
  // TODO : solve for # of ships based on circumference and frequency
  var num = Math.round(Math.random() * 7) + 2;
  // TODO : factor in offset into here somehow

  var spheres = [];
  var geometry = new THREE.SphereGeometry( 1, 32, 32 );
  var material = new THREE.MeshBasicMaterial( {color: colors[num-1], specular: 0x555555, shininess: 30, opacity: 0.8, transparent: true} );
  for (var i = 0; i < num; ++i) {
    var sphere = new THREE.Mesh( geometry, material );
    scene.add(sphere);
    spheres.push(sphere);
  }

  orbits.push({
    orbit: orbit,
    spheres: spheres,
    shipRotationRadians: shipRotationRadians,
    radius: distance,
    // TODO : get the actual angles based off the sketch
    orbitRotation: Math.random() * Math.PI * 2,
    shipRotation: 0,
  });
}

var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );


generateOrbit(1, 3, 1, 1.5, 12, scene);
generateOrbit(2, 5, 3, 3.5, 3, scene);
generateOrbit(3, 6, 3, 6, 4, scene);
generateOrbit(4, 10, 0, 8, 9, scene);
generateOrbit(5, 12, 0, 10, 7, scene);
generateOrbit(6, 15, 0, 15, 2, scene);

camera.position.z = 10;

var dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(100, 100, 50);
scene.add(dirLight);

var bluePoint = new THREE.PointLight(0x0033ff, 3, 150);
bluePoint.position.set( 70, 5, 70 );
scene.add(bluePoint);
scene.add(new THREE.PointLightHelper(bluePoint, 3));

var greenPoint = new THREE.PointLight(0x33ff00, 1, 150);
greenPoint.position.set( -70, 5, 70 );
scene.add(greenPoint);
scene.add(new THREE.PointLightHelper(greenPoint, 3));

var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
directionalLight.position.set( 0, 1, 0 );
scene.add( directionalLight );
var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );


var orbit_rotation_vector = new THREE.Vector3(0,1,0);
var ship_rotation_vector = new THREE.Vector3(0,0,1);
function render() {
    //   orbit: orbit,
    // spheres: spheres,
    // shipRotationRadians: shipRotationRadians,
    // radius: distance,
    // orbitRotation: Math.random() * Math.PI * 2,
    // shipRotation: 0,
  for(var i = 0; i < orbits.length; ++i) {
    var o = orbits[i];

    o.orbit.matrix.makeRotationAxis(orbit_rotation_vector, o.orbitRotation);
    o.orbit.matrixAutoUpdate = false;
    o.shipRotation += o.shipRotationRadians/100;
    for(var j = 0; j < o.spheres.length; ++j) {
      var s = o.spheres[j];
      var rotationOffset = j * Math.PI * 2 / o.spheres.length;
      // applyAxisAngle(normalized vector3, angle in radians)
      var shipVector = new THREE.Vector3(0, o.radius, 0).applyAxisAngle(ship_rotation_vector, o.shipRotation + rotationOffset);  // spin the ships around the ring
      shipVector.applyAxisAngle(orbit_rotation_vector, o.orbitRotation);  // twist the ring of ships to match the orbit
      s.matrix.setPosition(shipVector);
      s.matrixAutoUpdate = false;
    }
  }
  requestAnimationFrame( render );
  renderer.render( scene, camera );
}
render();
controls = new THREE.OrbitControls( camera, renderer.domElement );

    </script>
  </body>
</html>